#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import os from 'os';
import readline from 'readline';
import FormData from 'form-data';
import fetch from 'node-fetch';
import { fileURLToPath } from 'url';

// For certain Node ESM behaviors (like __dirname):
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// -----------------------------------------------------------------------------
// 1) Load user config from ~/.config/charm/config.json (if present)
// -----------------------------------------------------------------------------
function loadUserConfig() {
  const configPath = path.join(os.homedir(), '.config', 'charm', 'config.json');
  let userConfig = {};
  try {
    if (fs.existsSync(configPath)) {
      const text = fs.readFileSync(configPath, 'utf-8');
      userConfig = JSON.parse(text);
    }
  } catch (err) {
    console.warn(`[WARN] Could not parse config at ${configPath}:`, err.message);
  }
  return userConfig;
}

const defaultConfig = {
  port: 5002,
  hostname: 'localhost',
  baseUrlPrefix: '/charm',
  model: 'gpt-4o-mini'
};

const userConfig = loadUserConfig();
const mergedConfig = { ...defaultConfig, ...userConfig };

// -----------------------------------------------------------------------------
// 2) Parse Command-Line Arguments (global + subcommand)
// -----------------------------------------------------------------------------
function parseArgs(argv) {
  const args = [...argv];
  const parsed = {
    _global: {},
    command: null,
    commandArgs: []
  };

  function nextArg() {
    return args.shift();
  }

  // Remove "node" + script name if present
  if (args[0] && args[0].match(/node(\.exe)?$/i)) args.shift();
  if (args[0] && path.basename(args[0]) === path.basename(__filename)) args.shift();

  // Parse global flags
  while (args.length > 0) {
    if (!args[0].startsWith('--')) {
      // The first non-flag token is the subcommand
      parsed.command = args.shift();
      break;
    }
    const flag = args.shift();
    switch (flag) {
      case '--base-url-prefix':
        parsed._global.baseUrlPrefix = nextArg();
        break;
      case '--model':
        parsed._global.model = nextArg();
        break;
      case '--port':
        parsed._global.port = parseInt(nextArg(), 10);
        break;
      case '--hostname':
        parsed._global.hostname = nextArg();
        break;
      default:
        console.error(`Unknown global flag: ${flag}`);
        process.exit(1);
    }
  }

  if (!parsed.command && args.length > 0) {
    parsed.command = args.shift();
  }
  parsed.commandArgs = args;
  return parsed;
}

const parsed = parseArgs(process.argv);

// -----------------------------------------------------------------------------
// 3) Merge final global flags
// -----------------------------------------------------------------------------
const finalGlobalFlags = {
  port: mergedConfig.port,
  hostname: mergedConfig.hostname,
  baseUrlPrefix: mergedConfig.baseUrlPrefix,
  model: mergedConfig.model
};

if (typeof parsed._global.port === 'number') {
  finalGlobalFlags.port = parsed._global.port;
}
if (typeof parsed._global.hostname === 'string') {
  finalGlobalFlags.hostname = parsed._global.hostname;
}
if (typeof parsed._global.baseUrlPrefix === 'string') {
  finalGlobalFlags.baseUrlPrefix = parsed._global.baseUrlPrefix;
}
if (typeof parsed._global.model === 'string') {
  finalGlobalFlags.model = parsed._global.model;
}

const command = parsed.command || 'help';
const cmdArgs = parsed.commandArgs;

// -----------------------------------------------------------------------------
// 4) Helpers for attachments, prompts, etc.
// -----------------------------------------------------------------------------
function guessMimeType(filePath) {
  const ext = path.extname(filePath).toLowerCase();
  switch (ext) {
    case '.png':
      return 'image/png';
    case '.jpg':
    case '.jpeg':
      return 'image/jpeg';
    case '.gif':
      return 'image/gif';
    default:
      return null;
  }
}

function makeImageAttachment(filePath) {
  const data = fs.readFileSync(filePath);
  const b64 = data.toString('base64');
  const mime = guessMimeType(filePath);
  if (!mime) {
    console.warn(`[WARN] Could not guess an image MIME type for file: ${filePath}`);
    return null;
  }
  return {
    type: 'image',
    url: `data:${mime};base64,${b64}`
  };
}

// Helper to read all lines from stdin
async function readAllStdin() {
  const rl = readline.createInterface({ input: process.stdin });
  let data = '';
  for await (const line of rl) {
    data += line + '\n';
  }
  return data.trim();
}

// A small wrapper to use readline in async style
function questionAsync(rl, prompt) {
  return new Promise(resolve => {
    rl.question(prompt, answer => resolve(answer));
  });
}

function sleep(seconds) {
  return new Promise(resolve => setTimeout(resolve, seconds * 1000));
}

// -----------------------------------------------------------------------------
// 5) "run" Subcommand
// -----------------------------------------------------------------------------
async function commandRun(globalFlags, cmdArgs) {
  let systemFile = null;
  let userInputFile = null;
  let forceFormat = null;
  let forceSchemaFile = null;
  let leftoverMessage = null;

  const attachments = [];
  const localArgs = [...cmdArgs];

  while (localArgs.length > 0) {
    const token = localArgs.shift();
    if (token === '--system') {
      systemFile = localArgs.shift();
    } else if (token === '--input-file') {
      userInputFile = localArgs.shift();
    } else if (token === '--force-response-format') {
      forceFormat = localArgs.shift();
    } else if (token === '--force-response-json-schema') {
      forceSchemaFile = localArgs.shift();
    } else if (token === '--attach') {
      const attachPath = localArgs.shift();
      if (!attachPath) {
        console.error('[ERROR] --attach requires a file path argument.');
        process.exit(1);
      }
      const attachObj = makeImageAttachment(attachPath);
      if (!attachObj) {
        console.error(`[ERROR] Could not attach file: ${attachPath}`);
        process.exit(1);
      }
      attachments.push(attachObj);
    } else if (token.startsWith('--')) {
      console.error(`Unknown flag for "run": ${token}`);
      process.exit(1);
    } else {
      // remainder is user message
      leftoverMessage = token + ' ' + localArgs.join(' ');
      localArgs.length = 0;
    }
  }

  // Resolve user message
  let userMessage = '';
  if (leftoverMessage) {
    userMessage = leftoverMessage.trim();
  } else if (userInputFile) {
    userMessage = fs.readFileSync(userInputFile, 'utf-8');
  } else {
    // If there's no leftover message or file, try stdin
    userMessage = await readAllStdin();
  }

  if (!userMessage && attachments.length === 0) {
    console.error('[ERROR] No user message and no attachments provided.');
    process.exit(1);
  }

  let systemText = null;
  if (systemFile) {
    systemText = fs.readFileSync(systemFile, 'utf-8');
  }

  if (forceFormat && forceSchemaFile) {
    console.error('[ERROR] Cannot specify both --force-response-format and --force-response-json-schema.');
    process.exit(1);
  }

  const invocationOptions = {};
  if (forceFormat) {
    invocationOptions.response_format = { type: forceFormat };
  }
  if (forceSchemaFile) {
    const schemaText = fs.readFileSync(forceSchemaFile, 'utf-8');
    let schemaObj = null;
    try {
      schemaObj = JSON.parse(schemaText);
    } catch (err) {
      console.error(`[ERROR] Could not parse JSON schema from file ${forceSchemaFile}`);
      process.exit(1);
    }
    invocationOptions.response_format = {
      type: 'json_schema',
      json_schema: { name: 'forced-schema', schema: schemaObj }
    };
  }

  // Build the user content
  let userContent;
  if (attachments.length === 0) {
    userContent = userMessage;
  } else {
    const arr = [];
    if (userMessage) {
      arr.push(userMessage);
    }
    for (const att of attachments) {
      arr.push(att);
    }
    userContent = arr;
  }

  const payload = {
    model: globalFlags.model,
    transcript: {
      messages: [
        { role: 'user', content: userContent }
      ]
    }
  };
  if (systemText) {
    payload.system = systemText;
  }
  if (Object.keys(invocationOptions).length > 0) {
    payload.options = invocationOptions;
  }

  const endpoint = `http://${globalFlags.hostname}:${globalFlags.port}${globalFlags.baseUrlPrefix}/api/charmonator/v1/chat/extend_transcript`;
  try {
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    if (!response.ok) {
      const errBody = await response.text();
      console.error(`[ERROR] HTTP ${response.status} => ${errBody}`);
      process.exit(1);
    }
    const resultJson = await response.json();
    // typically { messages: [...] }
    const assistantMessages = (resultJson.messages || []).filter(m => m.role === 'assistant');
    if (assistantMessages.length === 0) {
      console.log('(No assistant message returned.)');
      return;
    }
    for (const msg of assistantMessages) {
      if (typeof msg.content === 'string') {
        console.log(msg.content);
      } else if (Array.isArray(msg.content)) {
        msg.content.forEach(segment => {
          if (typeof segment === 'string') {
            console.log(segment);
          } else {
            console.log(`[Attachment returned: ${JSON.stringify(segment)}]`);
          }
        });
      } else {
        console.log(String(msg.content));
      }
    }
  } catch (err) {
    console.error('[ERROR] Failed to call /chat/extend_transcript:', err.message);
    process.exit(1);
  }
}

// -----------------------------------------------------------------------------
// 5b) "chat" Subcommand (New): Interactive chat loop
// -----------------------------------------------------------------------------
async function commandChat(globalFlags, cmdArgs) {
  // Optionally accept a system prompt file: --system <path>
  let systemFile = null;
  const localArgs = [...cmdArgs];
  while (localArgs.length > 0) {
    if (localArgs[0] === '--system') {
      localArgs.shift();
      systemFile = localArgs.shift();
    } else {
      console.error(`[ERROR] Unknown flag for "chat": ${localArgs[0]}`);
      process.exit(1);
    }
  }

  let systemText = null;
  if (systemFile) {
    try {
      systemText = fs.readFileSync(systemFile, 'utf-8');
    } catch (err) {
      console.error(`[ERROR] Could not read --system file: ${systemFile}\n`, err.message);
      process.exit(1);
    }
  }

  // We'll maintain a transcript object in memory:
  const transcript = { messages: [] };

  console.log('Entering chat mode. Type "exit" or "quit" to end.\n');
  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });

  while (true) {
    const userInput = await questionAsync(rl, '> ');
    if (!userInput.trim()) continue;
    if (userInput.toLowerCase() === 'exit' || userInput.toLowerCase() === 'quit') {
      console.log('Exiting chat.');
      break;
    }

    // Add user message to the transcript
    transcript.messages.push({ role: 'user', content: userInput });

    // Prepare request payload
    const payload = {
      model: globalFlags.model,
      transcript,
      options: { stream: false }
    };
    if (systemText) {
      payload.system = systemText;
    }

    // Call /chat/extend_transcript
    const endpoint = `http://${globalFlags.hostname}:${globalFlags.port}${globalFlags.baseUrlPrefix}/api/charmonator/v1/chat/extend_transcript`;
    let resultJson;
    try {
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!response.ok) {
        const errBody = await response.text();
        console.error(`[ERROR] HTTP ${response.status} => ${errBody}`);
        continue;
      }
      resultJson = await response.json();
    } catch (err) {
      console.error('[ERROR] Failed to call /chat/extend_transcript:', err.message);
      continue;
    }

    // Append the assistant’s messages to the transcript and display them
    const assistantMessages = (resultJson.messages || []).filter(m => m.role === 'assistant');
    for (const msg of assistantMessages) {
      transcript.messages.push(msg);
      // Print the content
      if (typeof msg.content === 'string') {
        console.log(msg.content);
      } else if (Array.isArray(msg.content)) {
        msg.content.forEach(segment => {
          if (typeof segment === 'string') {
            console.log(segment);
          } else {
            console.log(`[Attachment returned: ${JSON.stringify(segment)}]`);
          }
        });
      } else {
        console.log(String(msg.content));
      }
    }
  }

  rl.close();
}

// -----------------------------------------------------------------------------
// 6) "transcribe" Subcommand
// -----------------------------------------------------------------------------
async function commandTranscribe(globalFlags, cmdArgs) {
  if (cmdArgs.length === 0) {
    console.error('[ERROR] No file specified. Expecting a .pdf or .docx file.');
    process.exit(1);
  }
  const inputFile = cmdArgs[0];
  const ext = path.extname(inputFile).toLowerCase();

  let outputPath;
  if (ext === '.pdf') {
    outputPath = inputFile.replace(/\.pdf$/i, '.pdf.doc.json');
  } else if (ext === '.docx') {
    outputPath = inputFile.replace(/\.docx$/i, '.docx.doc.json');
  } else {
    outputPath = inputFile + '.doc.json';
  }

  let description = null;
  let intent = null;
  let graphicInstructions = null;
  let detectDocBoundaries = false;
  let pageNumbering = true;
  let ocrThreshold = 1.0;
  let pollInterval = 3;

  const localArgs = cmdArgs.slice(1);
  while (localArgs.length > 0) {
    const token = localArgs.shift();
    switch (token) {
      case '--output':
        outputPath = localArgs.shift();
        break;
      case '--description':
        description = localArgs.shift();
        break;
      case '--intent':
        intent = localArgs.shift();
        break;
      case '--graphic-instructions':
        graphicInstructions = localArgs.shift();
        break;
      case '--detect-document-boundaries':
        detectDocBoundaries = true;
        break;
      case '--no-page-numbering':
        pageNumbering = false;
        break;
      case '--ocr-threshold':
        ocrThreshold = localArgs.shift();
        break;
      case '--poll-interval':
        pollInterval = parseFloat(localArgs.shift());
        if (isNaN(pollInterval) || pollInterval <= 0) {
          console.error('[ERROR] Invalid --poll-interval.');
          process.exit(1);
        }
        break;
      default:
        console.error(`[ERROR] Unknown flag for "transcribe": ${token}`);
        process.exit(1);
    }
  }

  let fileBuffer;
  try {
    fileBuffer = fs.readFileSync(inputFile);
  } catch (err) {
    console.error(`[ERROR] Could not read file at ${inputFile}`, err.message);
    process.exit(1);
  }

  const form = new FormData();
  form.append('file', fileBuffer, path.basename(inputFile));
  form.append('model', globalFlags.model);

  if (description) form.append('description', description);
  if (intent) form.append('intent', intent);
  if (graphicInstructions) form.append('graphic_instructions', graphicInstructions);
  if (detectDocBoundaries) form.append('detect_document_boundaries', 'true');
  if (!pageNumbering) form.append('page_numbering', 'false');
  if (ocrThreshold !== null) form.append('ocr_threshold', ocrThreshold);

  console.log('Starting document conversion with options:\n', {
    model: globalFlags.model,
    description,
    intent,
    graphicInstructions,
    detect_document_boundaries: detectDocBoundaries,
    page_numbering: pageNumbering,
    ocr_threshold: ocrThreshold
  });

  let length;
  try {
    length = form.getLengthSync();
  } catch (err) {
    console.error('[ERROR] form.getLengthSync() failed:', err.message);
    process.exit(1);
  }

  const headers = {
    ...form.getHeaders(),
    'Content-Length': length
  };

  const endpoint = `http://${globalFlags.hostname}:${globalFlags.port}${globalFlags.baseUrlPrefix}/api/charmonizer/v1/conversions/documents`;

  let jobId;
  try {
    const response = await fetch(endpoint, {
      method: 'POST',
      body: form,
      headers
    });
    if (!response.ok) {
      const errBody = await response.text();
      console.error(`[ERROR] HTTP ${response.status} => ${errBody}`);
      process.exit(1);
    }
    const result = await response.json();
    if (!result.job_id) {
      console.error('[ERROR] No job_id returned by the server.');
      process.exit(1);
    }
    jobId = result.job_id;
  } catch (err) {
    console.error('[ERROR] Failed to start document conversion:', err.message);
    process.exit(1);
  }

  const statusUrl = `http://${globalFlags.hostname}:${globalFlags.port}${globalFlags.baseUrlPrefix}/api/charmonizer/v1/conversions/documents/${jobId}`;
  const resultUrl = `${statusUrl}/result`;

  while (true) {
    await sleep(pollInterval);

    let statusRes;
    try {
      const resp = await fetch(statusUrl);
      if (!resp.ok) {
        const errBody = await resp.text();
        console.error(`[ERROR] Polling => HTTP ${resp.status} => ${errBody}`);
        process.exit(1);
      }
      statusRes = await resp.json();
    } catch (err) {
      console.error('[ERROR] Polling job status failed:', err.message);
      process.exit(1);
    }

    if (statusRes.status === 'error') {
      console.error('[ERROR] Job error:', statusRes.error);
      process.exit(1);
    } else if (statusRes.status === 'complete') {
      console.log('Conversion complete! Fetching final result...');
      break;
    } else {
      const pagesTotal = statusRes.pages_total || 0;
      const pagesConverted = statusRes.pages_converted || 0;
      console.log(`Progress: ${pagesConverted}/${pagesTotal} pages... (status=${statusRes.status})`);
    }
  }

  let finalDoc;
  try {
    const resp = await fetch(resultUrl);
    if (!resp.ok && resp.status !== 202) {
      const errBody = await resp.text();
      console.error(`[ERROR] Could not retrieve final => HTTP ${resp.status} => ${errBody}`);
      process.exit(1);
    }
    if (resp.status === 202) {
      console.warn('[WARN] Still processing, got 202. Exiting with error code.');
      process.exit(1);
    }
    finalDoc = await resp.json();
  } catch (err) {
    console.error('[ERROR] Failed to fetch final doc object:', err.message);
    process.exit(1);
  }

  try {
    fs.writeFileSync(outputPath, JSON.stringify(finalDoc, null, 2), 'utf-8');
    console.log(`Saved final doc object to ${outputPath}`);
  } catch (err) {
    console.error('[ERROR] Could not write output:', err.message);
    process.exit(1);
  }
}

// -----------------------------------------------------------------------------
// 7) "extract-markdown" Subcommand
// -----------------------------------------------------------------------------
async function commandExtractMarkdown(globalFlags, cmdArgs) {
  if (cmdArgs.length === 0) {
    console.error('[ERROR] No input file specified for "extract-markdown".');
    process.exit(1);
  }
  const inputPath = cmdArgs[0];

  let defaultOutput = inputPath + '.md';
  const ext = path.extname(inputPath);
  if (ext) {
    defaultOutput = inputPath.slice(0, -ext.length) + '.md';
  }

  let outputPath = defaultOutput;
  const localArgs = cmdArgs.slice(1);
  while (localArgs.length > 0) {
    const token = localArgs.shift();
    switch (token) {
      case '--output':
        outputPath = localArgs.shift();
        break;
      default:
        console.error(`[ERROR] Unknown flag for "extract-markdown": ${token}`);
        process.exit(1);
    }
  }

  let fileBuffer;
  try {
    fileBuffer = fs.readFileSync(inputPath);
  } catch (err) {
    console.error(`[ERROR] Could not read file at ${inputPath}`, err.message);
    process.exit(1);
  }

  const form = new FormData();
  form.append('file', fileBuffer, path.basename(inputPath));

  const endpoint = `http://${globalFlags.hostname}:${globalFlags.port}${globalFlags.baseUrlPrefix}/api/charmonator/v1/conversion/file`;

  let responseJson;
  try {
    const length = form.getLengthSync();
    const headers = {
      ...form.getHeaders(),
      'Content-Length': length
    };

    const resp = await fetch(endpoint, {
      method: 'POST',
      body: form,
      headers
    });
    if (!resp.ok) {
      const errBody = await resp.text();
      console.error(`[ERROR] /conversion/file => HTTP ${resp.status} => ${errBody}`);
      process.exit(1);
    }
    responseJson = await resp.json();
  } catch (err) {
    console.error('[ERROR] Failed to call /conversion/file:', err.message);
    process.exit(1);
  }

  if (!responseJson || typeof responseJson.markdownContent !== 'string') {
    console.error('[ERROR] Response missing "markdownContent" field.');
    process.exit(1);
  }

  try {
    fs.writeFileSync(outputPath, responseJson.markdownContent, 'utf-8');
    console.log(`Extracted markdown saved to: ${outputPath}`);
  } catch (err) {
    console.error('[ERROR] Could not write Markdown output:', err.message);
    process.exit(1);
  }
}

// -----------------------------------------------------------------------------
// 8) "convert-server-config" Subcommand
// -----------------------------------------------------------------------------
function promptYesNo(question) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  return new Promise(resolve => {
    rl.question(question, answer => {
      rl.close();
      resolve(answer.trim().toLowerCase());
    });
  });
}

async function commandConvertServerConfig(globalFlags, cmdArgs) {
  if (cmdArgs.length < 1) {
    console.error('[ERROR] No path to server config.json provided.');
    process.exit(1);
  }
  const serverConfigPath = cmdArgs[0];

  let serverConf;
  try {
    const raw = fs.readFileSync(serverConfigPath, 'utf-8');
    serverConf = JSON.parse(raw);
  } catch (err) {
    console.error(`[ERROR] Could not read/parse server config at ${serverConfigPath}:`, err.message);
    process.exit(1);
  }

  const localConf = {};

  // 1) Pull port
  if (serverConf.server && typeof serverConf.server.port === 'number') {
    localConf.port = serverConf.server.port;
  } else {
    localConf.port = 5002;
  }

  // 2) Use hostname = 'localhost'
  localConf.hostname = 'localhost';

  // 3) baseUrl => baseUrlPrefix
  const rawBaseUrl =
    serverConf.server && serverConf.server.baseUrl
      ? serverConf.server.baseUrl
      : '/ai2';
  localConf.baseUrlPrefix = rawBaseUrl.replace(/^\/+/, '');

  // 4) default model
  if (serverConf.models && typeof serverConf.models === 'object') {
    const modelNames = Object.keys(serverConf.models);
    if (modelNames.length > 0) {
      localConf.model = modelNames[0];
    }
  }
  if (!localConf.model) {
    localConf.model = 'gpt-4o-mini';
  }

  const charmDir = path.join(os.homedir(), '.config', 'charm');
  const localPath = path.join(charmDir, 'config.json');

  if (fs.existsSync(localPath)) {
    console.log(`[INFO] A local config file already exists at: ${localPath}`);
    const answer = await promptYesNo('Overwrite? [y/N]: ');
    if (answer !== 'y') {
      console.log('Aborted.');
      process.exit(0);
    }
  }

  try {
    fs.mkdirSync(charmDir, { recursive: true });
  } catch (err) {
    // ignore if already exists
  }

  try {
    fs.writeFileSync(localPath, JSON.stringify(localConf, null, 2), 'utf-8');
    console.log(`Wrote local charm config to: ${localPath}`);
    console.log('Done.');
  } catch (err) {
    console.error('[ERROR] Could not write local charm config:', err.message);
    process.exit(1);
  }
}

// -----------------------------------------------------------------------------
// 9) "chunk" Subcommand
// -----------------------------------------------------------------------------
async function commandChunk(globalFlags, cmdArgs) {
  let inputPath = null;
  let strategy = null;
  let chunkSize = null;
  let inputChunkGroupName = 'all';
  let outputChunkGroupName = 'rechunked';
  let inline = false;
  let outputPath = null;
  let pollInterval = 3;

  const localArgs = [...cmdArgs];
  while (localArgs.length > 0) {
    const token = localArgs.shift();
    if (token === '--input') {
      inputPath = localArgs.shift();
    } else if (token === '--strategy') {
      strategy = localArgs.shift();
    } else if (token === '--chunk-size') {
      chunkSize = parseInt(localArgs.shift(), 10);
    } else if (token === '--input-chunk-group-name') {
      inputChunkGroupName = localArgs.shift();
    } else if (token === '--output-chunk-group-name') {
      outputChunkGroupName = localArgs.shift();
    } else if (token === '--inline') {
      inline = true;
    } else if (token === '--output') {
      outputPath = localArgs.shift();
    } else if (token === '--poll-interval') {
      pollInterval = parseFloat(localArgs.shift());
    } else {
      console.error(`[ERROR] Unknown flag for "chunk": ${token}`);
      process.exit(1);
    }
  }

  if (!inputPath) {
    console.error('[ERROR] You must specify --input <file.json>.');
    process.exit(1);
  }
  if (!strategy) {
    console.error('[ERROR] You must specify --strategy (e.g. "merge_and_split").');
    process.exit(1);
  }
  if (!chunkSize || chunkSize <= 0) {
    console.error('[ERROR] You must specify a positive --chunk-size (in tokens).');
    process.exit(1);
  }

  if (!outputPath) {
    if (inline) {
      outputPath = inputPath;
    } else {
      outputPath = inputPath.replace(/\.json$/i, '') + '.chunk.json';
    }
  }

  let docObj;
  try {
    const text = fs.readFileSync(inputPath, 'utf-8');
    docObj = JSON.parse(text);
  } catch (err) {
    console.error(`[ERROR] Could not read/parse input JSON file: ${inputPath}\n`, err.message);
    process.exit(1);
  }

  const body = {
    document: docObj,
    strategy,
    chunk_size: chunkSize,
    chunk_group: inputChunkGroupName
  };

  const endpoint = `http://${globalFlags.hostname}:${globalFlags.port}${globalFlags.baseUrlPrefix}/api/charmonizer/v1/chunkings`;
  let jobId;
  try {
    const resp = await fetch(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
    if (!resp.ok) {
      const errText = await resp.text();
      console.error(`[ERROR] chunking job request => HTTP ${resp.status} => ${errText}`);
      process.exit(1);
    }
    const json = await resp.json();
    jobId = json.job_id;
    if (!jobId) {
      console.error('[ERROR] Server did not return a job_id.');
      process.exit(1);
    }
    console.log(`Chunking job started. job_id=${jobId}`);
  } catch (err) {
    console.error('[ERROR] Failed to submit chunking job:', err.message);
    process.exit(1);
  }

  const statusUrl = `http://${globalFlags.hostname}:${globalFlags.port}${globalFlags.baseUrlPrefix}/api/charmonizer/v1/chunkings/${jobId}`;
  const resultUrl = `${statusUrl}/result`;

  while (true) {
    await sleep(pollInterval);

    let statusRes;
    try {
      const resp = await fetch(statusUrl);
      if (!resp.ok) {
        const errText = await resp.text();
        console.error(`[ERROR] Poll => HTTP ${resp.status} => ${errText}`);
        process.exit(1);
      }
      statusRes = await resp.json();
    } catch (err) {
      console.error('[ERROR] Polling chunking job failed:', err.message);
      process.exit(1);
    }

    if (statusRes.status === 'error') {
      console.error('[ERROR] Chunking job failed:', statusRes.error || '(Unknown error)');
      process.exit(1);
    } else if (statusRes.status === 'complete') {
      console.log('Chunking job complete! Fetching final result...');
      break;
    } else {
      console.log(`Status: ${statusRes.status}, progress=${statusRes.progress || 0}%`);
    }
  }

  let finalResult;
  try {
    const resp = await fetch(resultUrl);
    if (!resp.ok) {
      const errText = await resp.text();
      console.error(`[ERROR] Could not get final chunk result => HTTP ${resp.status} => ${errText}`);
      process.exit(1);
    }
    finalResult = await resp.json();
  } catch (err) {
    console.error('[ERROR] Failed to retrieve chunk result:', err.message);
    process.exit(1);
  }

  const newChunkArray = (finalResult.chunks || []).map((item, idx) => {
    return {
      id: docObj.id + '/' + outputChunkGroupName + '@' + idx,
      parent: docObj.id,
      content: item.chunk_data.body,
      metadata: {
        chunk_index: item.chunk_index,
        title: item.chunk_data.title
      }
    };
  });

  if (inline) {
    if (!docObj.chunks) {
      docObj.chunks = {};
    }
    docObj.chunks[outputChunkGroupName] = newChunkArray;
    try {
      fs.writeFileSync(outputPath, JSON.stringify(docObj, null, 2), 'utf-8');
      console.log(`Wrote updated doc (with new chunk group "${outputChunkGroupName}") to: ${outputPath}`);
    } catch (err) {
      console.error('[ERROR] Could not write output file:', err.message);
      process.exit(1);
    }
  } else {
    const newDoc = {
      id: docObj.id,
      content: docObj.content || '',
      metadata: docObj.metadata || {},
      chunks: {}
    };
    newDoc.chunks[outputChunkGroupName] = newChunkArray;
    try {
      fs.writeFileSync(outputPath, JSON.stringify(newDoc, null, 2), 'utf-8');
      console.log(`Wrote new JSON document with chunk group "${outputChunkGroupName}" to: ${outputPath}`);
    } catch (err) {
      console.error('[ERROR] Could not write output file:', err.message);
      process.exit(1);
    }
  }
}

// -----------------------------------------------------------------------------
// 10) "summarize" Subcommand
// -----------------------------------------------------------------------------
/**
 * This command orchestrates a summarization job against the /summaries endpoint.
 * By default, it does a "map" style summarization (summarizing each chunk individually).
 *
 * Flags include inline and file-based variants for:
 *   --merge-summaries-guidance / --merge-summaries-guidance-file
 *   --initial-summary         / --initial-summary-file
 *   --json-schema             / --json-schema-file
 *
 * Usage example:
 *   charm summarize
 *     --input doc.json
 *     --method map
 *     --chunk-group pages
 *     --context-chunks-before 0
 *     --context-chunks-after 0
 *     --guidance "Please keep these summaries short."
 *     --temperature 0.7
 *     --annotation-field summary
 *     --annotation-field-delta summary_delta
 *     --merge-summaries-guidance "Combine partial summaries carefully."
 *     --merge-summaries-guidance-file guidance.txt
 *     --initial-summary "Seed text"
 *     --initial-summary-file seed.txt
 *     --json-schema schema.json
 *     --json-schema-file alt-schema.json
 *     --inline
 *     --output-file out.doc.json
 *     --poll-interval 3
 */
async function commandSummarize(globalFlags, cmdArgs) {
  // Default parameter values
  let inputPath = null;
  let method = 'map'; // defaults to chunk-wise summarization
  let chunkGroup = 'pages';
  let contextBefore = 0;
  let contextAfter = 0;
  let guidance = null;
  let temperature = null;
  let annotationField = 'summary';
  let annotationFieldDelta = 'summary_delta';

  // We'll store either inline or file-based versions:
  let mergeSummariesGuidance = null;
  let initialSummary = null;

  // For JSON schema, we can have an inline path or a -file version:
  let jsonSchemaPath = null;

  let inline = false;
  let outputFile = null;
  let pollInterval = 3;

  const localArgs = [...cmdArgs];
  while (localArgs.length > 0) {
    const token = localArgs.shift();
    switch (token) {
      case '--input':
        inputPath = localArgs.shift();
        break;
      case '--method':
        method = localArgs.shift();
        break;
      case '--chunk-group':
        chunkGroup = localArgs.shift();
        break;
      case '--context-chunks-before':
        contextBefore = parseInt(localArgs.shift(), 10);
        break;
      case '--context-chunks-after':
        contextAfter = parseInt(localArgs.shift(), 10);
        break;
      case '--guidance':
        guidance = localArgs.shift();
        break;
      case '--temperature':
        temperature = parseFloat(localArgs.shift());
        break;
      case '--annotation-field':
        annotationField = localArgs.shift();
        break;
      case '--annotation-field-delta':
        annotationFieldDelta = localArgs.shift();
        break;

      // --- Merge Summaries Guidance ---
      case '--merge-summaries-guidance':
        if (mergeSummariesGuidance) {
          console.error('[ERROR] Already specified merge-summaries-guidance; cannot repeat.');
          process.exit(1);
        }
        mergeSummariesGuidance = localArgs.shift();
        break;
      case '--merge-summaries-guidance-file':
        if (mergeSummariesGuidance) {
          console.error('[ERROR] Cannot combine --merge-summaries-guidance with --merge-summaries-guidance-file.');
          process.exit(1);
        }
        {
          const filePath = localArgs.shift();
          try {
            mergeSummariesGuidance = fs.readFileSync(filePath, 'utf-8');
          } catch (err) {
            console.error(`[ERROR] Could not read file for --merge-summaries-guidance-file: ${filePath}\n`, err.message);
            process.exit(1);
          }
        }
        break;

      // --- Initial Summary ---
      case '--initial-summary':
        if (initialSummary) {
          console.error('[ERROR] Already specified initial-summary; cannot repeat.');
          process.exit(1);
        }
        initialSummary = localArgs.shift();
        break;
      case '--initial-summary-file':
        if (initialSummary) {
          console.error('[ERROR] Cannot combine --initial-summary with --initial-summary-file.');
          process.exit(1);
        }
        {
          const filePath = localArgs.shift();
          try {
            initialSummary = fs.readFileSync(filePath, 'utf-8');
          } catch (err) {
            console.error(`[ERROR] Could not read file for --initial-summary-file: ${filePath}\n`, err.message);
            process.exit(1);
          }
        }
        break;

      // --- JSON Schema (inline or file) ---
      case '--json-schema':
        if (jsonSchemaPath) {
          console.error('[ERROR] Already specified a schema source; cannot combine --json-schema with --json-schema-file.');
          process.exit(1);
        }
        // We'll treat this as a file path (existing behavior).
        jsonSchemaPath = localArgs.shift();
        break;
      case '--json-schema-file':
        if (jsonSchemaPath) {
          console.error('[ERROR] Already specified a schema source; cannot combine --json-schema with --json-schema-file.');
          process.exit(1);
        }
        jsonSchemaPath = localArgs.shift();
        break;

      // --- Output & Misc ---
      case '--inline':
        inline = true;
        break;
      case '--output-file':
        outputFile = localArgs.shift();
        break;
      case '--poll-interval':
        pollInterval = parseFloat(localArgs.shift());
        break;
      default:
        console.error(`[ERROR] Unknown flag for "summarize": ${token}`);
        process.exit(1);
    }
  }

  if (!inputPath) {
    console.error('[ERROR] You must specify --input <doc.json>.');
    process.exit(1);
  }
  // Decide on final output path if user didn't specify
  if (!inline && !outputFile) {
    // e.g. mydoc.doc.json => mydoc.summarized.doc.json
    outputFile = inputPath.replace(/\.doc\.json$/i, '') + '.summarized.doc.json';
  }

  // Read the input doc
  let docObj;
  try {
    const text = fs.readFileSync(inputPath, 'utf-8');
    docObj = JSON.parse(text);
  } catch (err) {
    console.error(`[ERROR] Could not read/parse: ${inputPath}\n`, err.message);
    process.exit(1);
  }

  // Build request body
  const body = {
    document: docObj,
    method,
    model: globalFlags.model
  };
  // For "map", we need chunk_group:
  if (method !== 'full') {
    body.chunk_group = chunkGroup;
    body.context_chunks_before = contextBefore;
    body.context_chunks_after = contextAfter;
  }
  if (guidance) body.guidance = guidance;
  if (typeof temperature === 'number') body.temperature = temperature;
  if (annotationField) body.annotation_field = annotationField;
  if (annotationFieldDelta) body.annotation_field_delta = annotationFieldDelta;
  if (mergeSummariesGuidance) body.merge_summaries_guidance = mergeSummariesGuidance;
  if (initialSummary) body.initial_summary = initialSummary;

  // If user supplied a JSON schema path:
  if (jsonSchemaPath) {
    try {
      const raw = fs.readFileSync(jsonSchemaPath, 'utf-8');
      const parsedSchema = JSON.parse(raw);
      body.json_schema = parsedSchema;
    } catch (err) {
      console.error(`[ERROR] Could not read/parse JSON schema file: ${jsonSchemaPath}\n`, err.message);
      process.exit(1);
    }
  }

  // Submit summarization job
  const endpoint = `http://${globalFlags.hostname}:${globalFlags.port}${globalFlags.baseUrlPrefix}/api/charmonizer/v1/summaries`;
  let jobId;
  try {
    const resp = await fetch(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
    if (!resp.ok) {
      const errText = await resp.text();
      console.error(`[ERROR] Summarization job => HTTP ${resp.status} => ${errText}`);
      process.exit(1);
    }
    const json = await resp.json();
    jobId = json.job_id;
    if (!jobId) {
      console.error('[ERROR] Server did not return a job_id.');
      process.exit(1);
    }
    console.log(`Summarization job started. job_id=${jobId}`);
  } catch (err) {
    console.error('[ERROR] Failed to submit summarization job:', err.message);
    process.exit(1);
  }

  // Poll for completion
  const statusUrl = `${endpoint}/${jobId}`;
  const resultUrl = `${statusUrl}/result`;
  while (true) {
    await sleep(pollInterval);
    let statusRes;
    try {
      const resp = await fetch(statusUrl);
      if (!resp.ok) {
        const errText = await resp.text();
        console.error(`[ERROR] Poll => HTTP ${resp.status} => ${errText}`);
        process.exit(1);
      }
      statusRes = await resp.json();
    } catch (err) {
      console.error('[ERROR] Polling summarization job failed:', err.message);
      process.exit(1);
    }
    if (statusRes.status === 'error') {
      console.error('[ERROR] Summarization job failed:', statusRes.error || '(No error detail)');
      process.exit(1);
    } else if (statusRes.status === 'complete') {
      console.log('Summarization job complete! Fetching final result...');
      break;
    } else {
      console.log(`Status: ${statusRes.status}, chunks_completed=${statusRes.chunks_completed || 0}/` +
                  `${statusRes.chunks_total || 0}...`);
    }
  }

  // Fetch final summarized doc
  let finalDoc;
  try {
    const resp = await fetch(resultUrl);
    if (!resp.ok) {
      const errText = await resp.text();
      console.error(`[ERROR] Could not get final summary => HTTP ${resp.status} => ${errText}`);
      process.exit(1);
    }
    finalDoc = await resp.json();
  } catch (err) {
    console.error('[ERROR] Failed to retrieve summarization result:', err.message);
    process.exit(1);
  }

  // Write output
  let targetPath = outputFile || inputPath; // fallback if inline
  if (inline) {
    // If user didn't explicitly give --output-file, we overwrite the input
    if (!outputFile) {
      targetPath = inputPath;
    }
  }
  try {
    fs.writeFileSync(targetPath, JSON.stringify(finalDoc, null, 2), 'utf-8');
    console.log(`Wrote summarized doc to: ${targetPath}`);
  } catch (err) {
    console.error('[ERROR] Could not write output file:', err.message);
    process.exit(1);
  }
}

// -----------------------------------------------------------------------------
// X) Show Help
// -----------------------------------------------------------------------------
function showHelp() {
  console.log(`
Usage:
  charm [global-flags] <command> [options...]

Global Flags:
  --base-url-prefix <prefix>   (Default: "/charm" or config override)
  --model <modelName>          (Default: "gpt-4o-mini" or config override)
  --port <number>              (Default: 5002 or config override)
  --hostname <name>            (Default: "localhost" or config override)

Commands:
  run [flags] [<user message>]
    --system <file>
    --input-file <file>
    --force-response-format <format>
    --force-response-json-schema <file>
    --attach <file>       (Attach image(s) to the user message)

  chat [flags]
    --system <file>       (Load system instructions from file)
    (Enters an interactive chat loop. Type "quit" or "exit" to stop.)

  transcribe <file>.pdf|.docx [flags]
    --output <file>
    --description <string>
    --intent <string>
    --graphic-instructions <str>
    --detect-document-boundaries
    --no-page-numbering
    --ocr-threshold <float>
    --poll-interval <seconds>

  extract-markdown <file> [flags]
    --output <file>

  convert-server-config <path-to-charm-server-conf/config.json>
    Generates a minimal ~/.config/charm/config.json for the CLI
    based on the server config (used by charmonator/charmonizer).

  chunk [flags]
    --input <doc.json>
    --strategy <string>            (e.g. "merge_and_split")
    --chunk-size <int>             (max tokens per chunk)
    --input-chunk-group-name <str> (defaults to "all")
    --output-chunk-group-name <str>(defaults to "rechunked")
    --inline
    --output <file>
    --poll-interval <seconds>      (default=3)

  summarize [flags]
    --input <doc.json>
    --method <full|map|fold|delta-fold|map-merge|merge>
    --chunk-group <str>           (for non-"full" methods)
    --context-chunks-before <int>
    --context-chunks-after <int>
    --guidance <string>
    --temperature <float>
    --annotation-field <str>
    --annotation-field-delta <str>
    --merge-summaries-guidance <str>
    --merge-summaries-guidance-file <file>
    --initial-summary <str>
    --initial-summary-file <file>
    --json-schema <file>
    --json-schema-file <file>
    --inline
    --output-file <path>
    --poll-interval <seconds>      (default=3)

Examples:
  charm run "Hello"
  charm run --attach cat.png "Here's my cat!"
  charm --model gpt-4o run --system system.md --force-response-format json_object "Time?"
  charm transcribe mydoc.pdf --description "A PDF doc" --poll-interval 5
  charm extract-markdown sample.pdf
  charm convert-server-config /path/to/server/config.json

  charm chat --system system.md

  charm chunk --input mydoc.doc.json --strategy merge_and_split --chunk-size 1000
              --input-chunk-group-name pages
              --output-chunk-group-name splittedPages
              --inline
              --output mydoc.updated.json

  charm summarize
    --input mydoc.doc.json
    --method map
    --chunk-group pages
    --context-chunks-before 0
    --context-chunks-after 0
    --guidance "Keep it short."
    --temperature 0.7
    --annotation-field "summary"
    --annotation-field-delta "summary_delta"
    --merge-summaries-guidance "Some single-line text"
    --merge-summaries-guidance-file guidance.txt
    --initial-summary-file seed.txt
    --json-schema-file schema.json
    --inline
    --output-file final.doc.json
    --poll-interval 3
`);
}

// -----------------------------------------------------------------------------
// Main
// -----------------------------------------------------------------------------
async function main() {
  if (command === 'help' || command === null) {
    showHelp();
    process.exit(0);
  }

  switch (command) {
    case 'run':
      await commandRun(finalGlobalFlags, cmdArgs);
      break;
    case 'chat':
      await commandChat(finalGlobalFlags, cmdArgs);
      break;
    case 'transcribe':
      await commandTranscribe(finalGlobalFlags, cmdArgs);
      break;
    case 'extract-markdown':
      await commandExtractMarkdown(finalGlobalFlags, cmdArgs);
      break;
    case 'convert-server-config':
      await commandConvertServerConfig(finalGlobalFlags, cmdArgs);
      break;
    case 'chunk':
      await commandChunk(finalGlobalFlags, cmdArgs);
      break;
    case 'summarize':
      await commandSummarize(finalGlobalFlags, cmdArgs);
      break;
    default:
      console.error(`[ERROR] Unknown command: ${command}`);
      showHelp();
      process.exit(1);
  }
}

main().catch(err => {
  console.error('[ERROR] Uncaught exception in charm script:', err);
  process.exit(1);
});
